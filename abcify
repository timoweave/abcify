#!/usr/bin/env node
("use strict");

const fs = require('fs');
const path = require('path');
const yargs = require('yargs');
const recast = require('recast');
const flow_parser = require("flow-parser");

const JSXATTRIBUTE = 'JSXAttribute';
const LITERAL = 'Literal';
const IMPORTSPECIFIER = 'ImportSpecifier';
const NULL = 'NullLiteralTypeAnnotation';
const GENERIC = 'GenericTypeAnnotation';
const NUMBER = 'NumberLiteralTypeAnnotation'
const BOOLEAN = 'BooleanLiteralTypeAnnotation';
const UNDEFINED = 'undefined';
const IDENTIFIER = 'Identifier';

const is_undefined = (a) => ((a.type === GENERIC) &&
                             (a.id.type === IDENTIFIER) &&
                             (a.id.name === UNDEFINED));

function sort_ast(ast, token, node, comparator) {
  recast.types.visit(ast, {
    [token]: function (path) {
      this.traverse(path);
      path.value[node].sort(comparator);
    },
  });
}


function compare_name(a_name, b_name) {
  const a_len = a_name === null ? 0 : a_name.length;
  const b_len = b_name === null ? 0 : b_name.length;

  for (let a_i = 0, b_i = 0; a_i < a_len && b_i < b_len; a_i++, b_i++) {
    const a_num = a_name !== null ? a_name[a_i].charCodeAt(0) : 0;
    const b_num = b_name !== null ? b_name[b_i].charCodeAt(0) : 0;
    if (a_num !== b_num) {
      return a_num - b_num;
    }
  }
  return (a_len - b_len);
}

function compare_by_union(a, b) {
  if (is_undefined(a)){
      return -1;
  } else if (is_undefined(b)) {
      return 1;
  } else if (a.type === NULL) {
      return -1;
  } else if (b.type === NULL) {
      return 1;
  } else if ((a.type === BOOLEAN) && (b.type === BOOLEAN)) {
      return compare_name(a.raw, b.raw);
  } else if (a.type === BOOLEAN) {
      return -1;
  } else if (b.type === BOOLEAN) {
      return 1;      
  } else if ((a.type === NUMBER) && (b.type === NUMBER)) {
      return a.value - b.value;
  } else if (a.type === NUMBER) {
      return -1;
  } else if (b.type === NUMBER) {
      return 1;      
  } else {
      return compare_name(a.raw, b.raw);
  }
}

function compare_by_object(a, b) {
  const a_name =
	a.key.type === IDENTIFIER ? a.key.name :
	a.key.type === LITERAL ? a.key.value :
        null;
  const b_name =
	b.key.type === IDENTIFIER ? b.key.name :
	b.key.type === LITERAL ? b.key.value :
        null;

  return compare_name(a_name, b_name);
}

function compare_by_imported(a, b) {
  const a_name = a.type === IMPORTSPECIFIER ? a.imported.name : null;
  const b_name = b.type === IMPORTSPECIFIER ? b.imported.name : null;

  return compare_name(a_name, b_name);
}

function compare_by_attribute(a, b) {
  const a_name = a.type === JSXATTRIBUTE ? a.name.name : null;
  const b_name = b.type === JSXATTRIBUTE ? b.name.name : null;

  return compare_name(a_name, b_name);
}

function create_ast(filepath) {
  if (!fs.existsSync(filepath)) {
    console.warn(`WARNING: ${filepath} does not exist`);
    return null;
  }
  const source_code = fs.readFileSync(filepath, 'utf8');
  if (!source_code) {
    return null;
  }
  return recast.parse(source_code, {parser: flow_parser});
}

function parse_cmd_args() {
  const {argv} = yargs
	.usage('Usage: $0 <command> [options]')
	.describe('s', 'save the transformed output back to the input file')
	.demandCommand(1);
  return argv;
}

function abcify(filename, save = false) {
  const filepath = path.resolve(filename);
  const ast = create_ast(filepath);

  sort_ast(ast, "visitImportDeclaration", "specifiers", compare_by_imported);
  sort_ast(ast, "visitObjectExpression", "properties", compare_by_object);
  sort_ast(ast, "visitObjectPattern", "properties", compare_by_object);
  sort_ast(ast, "visitJSXOpeningElement", "attributes", compare_by_attribute);
  sort_ast(ast, "visitObjectTypeAnnotation", "properties", compare_by_object);
  sort_ast(ast, "visitUnionTypeAnnotation", "types", compare_by_union);

  const {code: sorted_code} = recast.print(ast);
  if (!save) {
    console.log(sorted_code);	
  } else {
    fs.writeFileSync(filepath, sorted_code);
  }
}

if (require.main === module) {
  const args = parse_cmd_args();
  const {s: save = false, _: filenames} = args;
  filenames.forEach((filename) => abcify(filename, save));
}

module.exports = {
  abcify
};
